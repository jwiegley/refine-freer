#+TITLE: The Process of Refinement

This documents seeks to unify Conal Elliott's "Denotational Design" approach
and metholodogy, with the Fiat library and its application in Coq.

* Fiat

In Fiat, we begin by defining an ADT over an existential representation type,
along with a set of methods that refer to this type. Each method is written in
the form =input -> rep -> output * rep=, making every function a "transformer
of rep-typed values" unless it chooses to pass it through.

Note that after having written this "top level specification", we can
establish theorem about the semantics of the spec as a whole, such as the fact
that freeing immediately after allocating leaves the heap unchanged.

Refinement is the process of choosing a more concrete rep type, and an
abstraction relation between the old and new types of the form =oldRep ->
newRep -> Prop=. One is then presented with the obligation of proving that the
semantics of every method is maintained over this relation, while further
restricting that none of the methods' other types may change: only the
internal representation type.

This continues stepwise until one reaches a final, computable refinement. Note
that all steps until the final are done in a relational setting, using a
=Comp= monad to ease the writing of such code in Coq.

* Denotational Design

In Denotation Design, we begin by denoting our subject of interest as some
mathematical object, and then we discover or define algebras that are
descriptive of how we intend to use this object.

If we invent our own algebra (though this is generally to be avoided, if
possible), we must also define the laws that hold for this algebra. For the
algebra of "allocation", for example, we may define that alloc followed by
free has no effect.

Once we have fleshed out the domain of the denotation, we choose a
representation type to work with that addresses any operational concerns. We
then write a denoting function from this representation type to the original
denotation.

Next we must implement representation-specific versions of all our algebraic
functions, and prove that the denoting function is a homomorphic over all
these algebras. This proves that the domain of the representation is fully
specified by the domain of the denotation.

* Matching them up

| Fiat                  | Denotational Design          |
|-----------------------+------------------------------|
| Initial rep type      | Denotation                   |
| ADT methods           | Algebras over the denotation |
| Subsequent rep types  | Representations              |
| Abstraction relations | Denoting functions           |
| Refinement proofs     | Homomorphism proofs          |

* Differences to note

In Fiat, the initial rep type is often not a function -- as it tends to be in
denotational design -- but is still chosen to be the simplest mathematical
object that can support the ADT's methods while encoding needed assumptions.

In Fiat all ADT methods take and return the rep type. In denotational design a
function over the denotational object may do so, or may just return a value.

In Fiat all ADT methods are relational, even when they are equivalent to
functions. In denotational design, algebraic functions are more often just
that, but they can be relations too.

In Fiat the abstraction relation is always a relation. In denotational design
the denoting function is more typically just a function, but it can be a
relation as well.

In Fiat refinement proofs are generated by the framework, so their functoral
nature as homomorphic mappings under the abstraction relation is somewhat
hidden from the user. In denotational design this a key point in the approach,
so the practice of writing out the homomorphisms helps guide a full
understanding of the meaning of the denoting function.
